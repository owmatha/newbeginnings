#include "notGPT.h"
#include "ImprovedDictionary.h"
#include <fstream>
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function: notGPT
// Purpose: Constructor that seeds the rng and loads the input file
// Input: None
// Output: None
// Author: Owen Mather (10592925)
// Date: 07/05/2025
notGPT::notGPT() {
    rng.seed(random_device{}());
    loadText("littleprince.txt");
}

// Function: generateMyText
// Purpose: Generates English-like text
// Input: None
// Output: None
// Author: Owen Mather (10592925)
// Date: 08/05/2025
void notGPT::generateMyText() {
    this->generateText();
}

// Function: getGeneratedText
// Purpose: Returns the paragraph generated by the most recent call to generateText
// Input: None
// Output: A paragraph string
// Author: Owen Mather (10592925)
// Date: 08/05/2025
string notGPT::getGeneratedText() {
    return outputText;
}

// Function: returnProbabilities
// Purpose: Displays the top three most likely characters following a two-character input
// Input: Two-character string
// Output: Printed result returns nothing
// Author: Owen Mather (10592925)
// Date: 08/05/2025
void notGPT::returnProbabilities(const string& letters) {
    vector<pair<char, int>> counts = {{'\0', 0}, {'\0', 0}, {'\0', 0}};
    int total = 0;

    for (const auto& entry : letterPairs[letters]) { // Horrible else-if statement to shuffle the top three
        total += entry.second;
        if (entry.second > counts[0].second) {
            counts[2] = counts[1];
            counts[1] = counts[0];
            counts[0] = entry;
        } else if (entry.second > counts[1].second) {
            counts[2] = counts[1];
            counts[1] = entry;
        } else if (entry.second > counts[2].second) {
            counts[2] = entry;
        }
    }

    for (const auto& countings : counts) {
        cout << "'" << countings.first << "' => " << countings.second << " = " << static_cast<double>(countings.second) / total * 100 << "%" << endl;
    }
}

// Function: loadText
// Purpose: Reads and filters input text, stores letter pairs and character frequencies
// Input: Filename (string)
// Output: None
// Author: Owen Mather (10592925)
// Date: 07/05/2025
void notGPT::loadText(const string& fileName) {
    string allowedChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,' ";
    ifstream textFile{fileName};
    string rawText{istreambuf_iterator<char>(textFile), istreambuf_iterator<char>()};
    textFile.close();

    for (char& c : rawText) {
        if (allowedChars.find(c) != string::npos) {
            myText += tolower(c);
        }
    }

    for (size_t i = 0; i < myText.length() - 2; ++i) {
        string key = myText.substr(i, 2);
        letterPairs[key][myText[i + 2]] += 1;
    }
}

// Function: generateStartingLetters
// Purpose: Selects a random valid letter pair to start generating a new word
// Input: None
// Output: Two-character starting string
// Author: Owen Mather (10592925)
// Date: 08/05/2025
string notGPT::generateStartingLetters() {
    string approvedStarters = "bcdefghjklmnopgrstuvwyz";
    uniform_int_distribution<> dist(0, approvedStarters.length() - 1);
    char nextLetter = approvedStarters[dist(rng)];
    return " "s + nextLetter;
}

// Function: generateWord
// Purpose: Constructs a made-up word using prediction model
// Input: Minimum and maximum word lengths (int)
// Output: A generated word (string)
// Author: Owen Mather (10592925)
// Date: 08/05/2025
string notGPT::generateWord(int lengMin, int lengMax) {
    string randomWord = generateStartingLetters();

    uniform_int_distribution<> lengthDist(lengMin, lengMax);
    int targetLength = lengthDist(rng);

    while (randomWord.size() < targetLength) {
        int totalWeight = 0;
        string key = randomWord.substr(randomWord.size() - 2);

        for (const auto& letter : letterPairs[key]) {
            if (letter.first == ' ' || letter.first == ',') continue;
            totalWeight += letter.second;
        }

        if (totalWeight == 0) break;

        uniform_int_distribution<> dist(0, totalWeight - 1);
        int myWeight = dist(rng);

        for (const auto& myPair : letterPairs[key]) {
            char ch = myPair.first;
            int count = myPair.second;
            if (ch == ' ' || ch == ',') continue;
            myWeight -= count;
            if (myWeight <= 0) {
                randomWord += ch;
                break;
            }
        }
    }

    return randomWord;
}

// Function: generateSentence
// Purpose: Builds a sentence made up of several generated words
// Input: Minimum and maximum number of words (int)
// Output: A sentence (string)
// Author: Owen Mather (10592925)
// Date: 08/05/2025
string notGPT::generateSentence(int lengMin, int lengMax) {
    string mySentence = "";

    uniform_int_distribution<> wordCountDist(lengMin, lengMax);
    int wordCount = wordCountDist(rng);

    for (int i = 0; i < wordCount; i++) {
        mySentence += this->generateWord();
    }
    // Makemy sentence pretty
    mySentence.erase(0, mySentence.find_first_not_of(' '));
    mySentence.erase(mySentence.find_last_not_of(' ') + 1);
    mySentence.erase(mySentence.find_last_not_of(',') + 1); //These shouldn't be here but just in case
    mySentence += ". ";
    mySentence[0] = toupper(mySentence[0]);

    return mySentence;
}

// Function: generateText
// Purpose: Produces a paragraph composed of multiple generated sentences
// Input: None
// Output: Stored internally in outputText
// Author: Owen Mather (10592925)
// Date: 08/05/2025
void notGPT::generateText() {
    this->outputText = ""; // make sure to clear the previous text
    uniform_int_distribution<> sentenceCountDist(4, 8);
    int sentenceCount = sentenceCountDist(rng);

    for (int i = 0; i < sentenceCount; ++i) {
        this->outputText += this->generateSentence();
    }
}
